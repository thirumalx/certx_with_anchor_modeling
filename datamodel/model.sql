-- DATABASE INITIALIZATION -----------------------------------------------------
--
-- The following code performs the initial setup of the PostgreSQL database with
-- required objects for the anchor database.
--
--------------------------------------------------------------------------------
-- create schema
CREATE SCHEMA IF NOT EXISTS certx;
-- set schema search path
SET search_path = certx;
-- KNOTS --------------------------------------------------------------------------------------------------------------
--
-- Knots are used to store finite sets of values, normally used to describe states
-- of entities (through knotted attributes) or relationships (through knotted ties).
-- Knots have their own surrogate identities and are therefore immutable.
-- Values can be added to the set over time though.
-- Knots should have values that are mutually exclusive and exhaustive.
-- Knots are unfolded when using equivalence.
--
-- ANCHORS AND ATTRIBUTES ---------------------------------------------------------------------------------------------
--
-- Anchors are used to store the identities of entities.
-- Anchors are immutable.
-- Attributes are used to store values for properties of entities.
-- Attributes are mutable, their values may change over one or more types of time.
-- Attributes have four flavors: static, historized, knotted static, and knotted historized.
-- Anchors may have zero or more adjoined attributes.
--
-- Anchor table -------------------------------------------------------------------------------------------------------
-- US_User table (with 2 attributes)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS certx.US_User (
    US_ID bigint generated by default as identity not null,
    Metadata_US bigint not null, 
    constraint pkUS_User primary key (
        US_ID 
    )
);
-- Historized attribute table -----------------------------------------------------------------------------------------
-- US_UID_User_UserId table (on US_User)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS certx.US_UID_User_UserId (
    US_UID_US_ID bigint not null,
    US_UID_User_UserId varchar(75) not null,
    US_UID_ChangedAt timestamp not null,
    Metadata_US_UID bigint not null,
    constraint fkUS_UID_User_UserId foreign key (
        US_UID_US_ID
    ) references certx.US_User (US_ID),
    constraint pkUS_UID_User_UserId primary key (
        US_UID_US_ID ,
        US_UID_ChangedAt
    ) include (
        US_UID_User_UserId
    )
);
-- Historized attribute table -----------------------------------------------------------------------------------------
-- US_NAM_User_Name table (on US_User)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS certx.US_NAM_User_Name (
    US_NAM_US_ID bigint not null,
    US_NAM_User_Name varchar(75) not null,
    US_NAM_ChangedAt timestamp not null,
    Metadata_US_NAM bigint not null,
    constraint fkUS_NAM_User_Name foreign key (
        US_NAM_US_ID
    ) references certx.US_User (US_ID),
    constraint pkUS_NAM_User_Name primary key (
        US_NAM_US_ID ,
        US_NAM_ChangedAt
    ) include (
        US_NAM_User_Name
    )
);
-- Anchor table -------------------------------------------------------------------------------------------------------
-- RO_Role table (with 1 attributes)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS certx.RO_Role (
    RO_ID bigint generated by default as identity not null,
    Metadata_RO bigint not null, 
    constraint pkRO_Role primary key (
        RO_ID 
    )
);
-- Static attribute table ---------------------------------------------------------------------------------------------
-- RO_NAM_Role_Name table (on RO_Role)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS certx.RO_NAM_Role_Name (
    RO_NAM_RO_ID bigint not null,
    RO_NAM_Role_Name varchar(75) not null,
    Metadata_RO_NAM bigint not null,
    constraint fkRO_NAM_Role_Name foreign key (
        RO_NAM_RO_ID
    ) references certx.RO_Role (RO_ID),
    constraint pkRO_NAM_Role_Name primary key (
        RO_NAM_RO_ID 
    ) include (
        RO_NAM_Role_Name
    )
);
-- Anchor table -------------------------------------------------------------------------------------------------------
-- AP_Application table (with 2 attributes)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS certx.AP_Application (
    AP_ID bigint generated by default as identity not null,
    Metadata_AP bigint not null, 
    constraint pkAP_Application primary key (
        AP_ID 
    )
);
-- Historized attribute table -----------------------------------------------------------------------------------------
-- AP_NAM_Application_Name table (on AP_Application)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS certx.AP_NAM_Application_Name (
    AP_NAM_AP_ID bigint not null,
    AP_NAM_Application_Name varchar(75) not null,
    AP_NAM_ChangedAt timestamp not null,
    Metadata_AP_NAM bigint not null,
    constraint fkAP_NAM_Application_Name foreign key (
        AP_NAM_AP_ID
    ) references certx.AP_Application (AP_ID),
    constraint pkAP_NAM_Application_Name primary key (
        AP_NAM_AP_ID ,
        AP_NAM_ChangedAt
    ) include (
        AP_NAM_Application_Name
    )
);
-- Static attribute table ---------------------------------------------------------------------------------------------
-- AP_UID_Application_UniqueId table (on AP_Application)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS certx.AP_UID_Application_UniqueId (
    AP_UID_AP_ID bigint not null,
    AP_UID_Application_UniqueId varchar(15) not null,
    Metadata_AP_UID bigint not null,
    constraint fkAP_UID_Application_UniqueId foreign key (
        AP_UID_AP_ID
    ) references certx.AP_Application (AP_ID),
    constraint pkAP_UID_Application_UniqueId primary key (
        AP_UID_AP_ID 
    ) include (
        AP_UID_Application_UniqueId
    )
);
-- Anchor table -------------------------------------------------------------------------------------------------------
-- CL_Client table (with 3 attributes)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS certx.CL_Client (
    CL_ID bigint generated by default as identity not null,
    Metadata_CL bigint not null, 
    constraint pkCL_Client primary key (
        CL_ID 
    )
);
-- Static attribute table ---------------------------------------------------------------------------------------------
-- CL_NAM_Client_Name table (on CL_Client)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS certx.CL_NAM_Client_Name (
    CL_NAM_CL_ID bigint not null,
    CL_NAM_Client_Name varchar(75) not null,
    Metadata_CL_NAM bigint not null,
    constraint fkCL_NAM_Client_Name foreign key (
        CL_NAM_CL_ID
    ) references certx.CL_Client (CL_ID),
    constraint pkCL_NAM_Client_Name primary key (
        CL_NAM_CL_ID 
    ) include (
        CL_NAM_Client_Name
    )
);
-- Historized attribute table -----------------------------------------------------------------------------------------
-- CL_EID_Client_Email table (on CL_Client)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS certx.CL_EID_Client_Email (
    CL_EID_CL_ID bigint not null,
    CL_EID_Client_Email varchar(100) not null,
    CL_EID_ChangedAt timestamp not null,
    Metadata_CL_EID bigint not null,
    constraint fkCL_EID_Client_Email foreign key (
        CL_EID_CL_ID
    ) references certx.CL_Client (CL_ID),
    constraint pkCL_EID_Client_Email primary key (
        CL_EID_CL_ID ,
        CL_EID_ChangedAt
    ) include (
        CL_EID_Client_Email
    )
);
-- Historized attribute table -----------------------------------------------------------------------------------------
-- CL_MNO_Client_MobileNumber table (on CL_Client)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS certx.CL_MNO_Client_MobileNumber (
    CL_MNO_CL_ID bigint not null,
    CL_MNO_Client_MobileNumber varchar(12) not null,
    CL_MNO_ChangedAt timestamp not null,
    Metadata_CL_MNO bigint not null,
    constraint fkCL_MNO_Client_MobileNumber foreign key (
        CL_MNO_CL_ID
    ) references certx.CL_Client (CL_ID),
    constraint pkCL_MNO_Client_MobileNumber primary key (
        CL_MNO_CL_ID ,
        CL_MNO_ChangedAt
    ) include (
        CL_MNO_Client_MobileNumber
    )
);
-- Anchor table -------------------------------------------------------------------------------------------------------
-- CE_Certificate table (with 6 attributes)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS certx.CE_Certificate (
    CE_ID bigint generated by default as identity not null,
    Metadata_CE bigint not null, 
    constraint pkCE_Certificate primary key (
        CE_ID 
    )
);
-- Static attribute table ---------------------------------------------------------------------------------------------
-- CE_ION_Certificate_IssuedOn table (on CE_Certificate)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS certx.CE_ION_Certificate_IssuedOn (
    CE_ION_CE_ID bigint not null,
    CE_ION_Certificate_IssuedOn timestamp with time zone not null,
    Metadata_CE_ION bigint not null,
    constraint fkCE_ION_Certificate_IssuedOn foreign key (
        CE_ION_CE_ID
    ) references certx.CE_Certificate (CE_ID),
    constraint pkCE_ION_Certificate_IssuedOn primary key (
        CE_ION_CE_ID 
    ) include (
        CE_ION_Certificate_IssuedOn
    )
);
-- Static attribute table ---------------------------------------------------------------------------------------------
-- CE_RON_Certificate_RevokedOn table (on CE_Certificate)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS certx.CE_RON_Certificate_RevokedOn (
    CE_RON_CE_ID bigint not null,
    CE_RON_Certificate_RevokedOn timestamp with time zone not null,
    Metadata_CE_RON bigint not null,
    constraint fkCE_RON_Certificate_RevokedOn foreign key (
        CE_RON_CE_ID
    ) references certx.CE_Certificate (CE_ID),
    constraint pkCE_RON_Certificate_RevokedOn primary key (
        CE_RON_CE_ID 
    ) include (
        CE_RON_Certificate_RevokedOn
    )
);
-- Static attribute table ---------------------------------------------------------------------------------------------
-- CE_SNO_Certificate_SerialNumber table (on CE_Certificate)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS certx.CE_SNO_Certificate_SerialNumber (
    CE_SNO_CE_ID bigint not null,
    CE_SNO_Certificate_SerialNumber varchar(25) not null,
    Metadata_CE_SNO bigint not null,
    constraint fkCE_SNO_Certificate_SerialNumber foreign key (
        CE_SNO_CE_ID
    ) references certx.CE_Certificate (CE_ID),
    constraint pkCE_SNO_Certificate_SerialNumber primary key (
        CE_SNO_CE_ID 
    ) include (
        CE_SNO_Certificate_SerialNumber
    )
);
-- Static attribute table ---------------------------------------------------------------------------------------------
-- CE_LTV_Certificate_LastTimeVerifiedOn table (on CE_Certificate)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS certx.CE_LTV_Certificate_LastTimeVerifiedOn (
    CE_LTV_CE_ID bigint not null,
    CE_LTV_Certificate_LastTimeVerifiedOn timestamp with time zone not null,
    Metadata_CE_LTV bigint not null,
    constraint fkCE_LTV_Certificate_LastTimeVerifiedOn foreign key (
        CE_LTV_CE_ID
    ) references certx.CE_Certificate (CE_ID),
    constraint pkCE_LTV_Certificate_LastTimeVerifiedOn primary key (
        CE_LTV_CE_ID 
    ) include (
        CE_LTV_Certificate_LastTimeVerifiedOn
    )
);
-- Static attribute table ---------------------------------------------------------------------------------------------
-- CE_CEP_Certificate_CertificatePath table (on CE_Certificate)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS certx.CE_CEP_Certificate_CertificatePath (
    CE_CEP_CE_ID bigint not null,
    CE_CEP_Certificate_CertificatePath text not null,
    Metadata_CE_CEP bigint not null,
    constraint fkCE_CEP_Certificate_CertificatePath foreign key (
        CE_CEP_CE_ID
    ) references certx.CE_Certificate (CE_ID),
    constraint pkCE_CEP_Certificate_CertificatePath primary key (
        CE_CEP_CE_ID 
    ) include (
        CE_CEP_Certificate_CertificatePath
    )
);
-- Static attribute table ---------------------------------------------------------------------------------------------
-- CE_NAF_Certificate_NotAfter table (on CE_Certificate)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS certx.CE_NAF_Certificate_NotAfter (
    CE_NAF_CE_ID bigint not null,
    CE_NAF_Certificate_NotAfter timestamp with time zone not null,
    Metadata_CE_NAF bigint not null,
    constraint fkCE_NAF_Certificate_NotAfter foreign key (
        CE_NAF_CE_ID
    ) references certx.CE_Certificate (CE_ID),
    constraint pkCE_NAF_Certificate_NotAfter primary key (
        CE_NAF_CE_ID 
    ) include (
        CE_NAF_Certificate_NotAfter
    )
);
-- Anchor table -------------------------------------------------------------------------------------------------------
-- NT_Notification table (with 2 attributes)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS certx.NT_Notification (
    NT_ID bigint generated by default as identity not null,
    Metadata_NT bigint not null, 
    constraint pkNT_Notification primary key (
        NT_ID 
    )
);
-- Static attribute table ---------------------------------------------------------------------------------------------
-- NT_SNT_Notification_SentAt table (on NT_Notification)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS certx.NT_SNT_Notification_SentAt (
    NT_SNT_NT_ID bigint not null,
    NT_SNT_Notification_SentAt timestamp with time zone not null,
    Metadata_NT_SNT bigint not null,
    constraint fkNT_SNT_Notification_SentAt foreign key (
        NT_SNT_NT_ID
    ) references certx.NT_Notification (NT_ID),
    constraint pkNT_SNT_Notification_SentAt primary key (
        NT_SNT_NT_ID 
    ) include (
        NT_SNT_Notification_SentAt
    )
);
-- Static attribute table ---------------------------------------------------------------------------------------------
-- NT_REC_Notification_RemainderCount table (on NT_Notification)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS certx.NT_REC_Notification_RemainderCount (
    NT_REC_NT_ID bigint not null,
    NT_REC_Notification_RemainderCount smallint not null,
    Metadata_NT_REC bigint not null,
    constraint fkNT_REC_Notification_RemainderCount foreign key (
        NT_REC_NT_ID
    ) references certx.NT_Notification (NT_ID),
    constraint pkNT_REC_Notification_RemainderCount primary key (
        NT_REC_NT_ID 
    ) include (
        NT_REC_Notification_RemainderCount
    )
);
-- TIES ---------------------------------------------------------------------------------------------------------------
--
-- Ties are used to represent relationships between entities.
-- They come in four flavors: static, historized, knotted static, and knotted historized.
-- Ties have cardinality, constraining how members may participate in the relationship.
-- Every entity that is a member in a tie has a specified role in the relationship.
-- Ties must have at least two anchor roles and zero or more knot roles.
--
-- Static tie table ---------------------------------------------------------------------------------------------------
-- US_has_RO_belongsTo table (having 2 roles)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS certx.US_has_RO_belongsTo (
    US_ID_has bigint not null, 
    RO_ID_belongsTo bigint not null, 
    Metadata_US_has_RO_belongsTo bigint not null,
    constraint US_has_RO_belongsTo_fkUS_has foreign key (
        US_ID_has
    ) references certx.US_User(US_ID), 
    constraint US_has_RO_belongsTo_fkRO_belongsTo foreign key (
        RO_ID_belongsTo
    ) references certx.RO_Role(RO_ID), 
    constraint pkUS_has_RO_belongsTo primary key (
        US_ID_has ,
        RO_ID_belongsTo 
    )
);
-- Static tie table ---------------------------------------------------------------------------------------------------
-- US_accessTo_AP_has table (having 2 roles)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS certx.US_accessTo_AP_has (
    US_ID_accessTo bigint not null, 
    AP_ID_has bigint not null, 
    Metadata_US_accessTo_AP_has bigint not null,
    constraint US_accessTo_AP_has_fkUS_accessTo foreign key (
        US_ID_accessTo
    ) references certx.US_User(US_ID), 
    constraint US_accessTo_AP_has_fkAP_has foreign key (
        AP_ID_has
    ) references certx.AP_Application(AP_ID), 
    constraint pkUS_accessTo_AP_has primary key (
        US_ID_accessTo ,
        AP_ID_has 
    )
);
-- Static tie table ---------------------------------------------------------------------------------------------------
-- AP_serves_CL_servedBy table (having 2 roles)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS certx.AP_serves_CL_servedBy (
    AP_ID_serves bigint not null, 
    CL_ID_servedBy bigint not null, 
    Metadata_AP_serves_CL_servedBy bigint not null,
    constraint AP_serves_CL_servedBy_fkAP_serves foreign key (
        AP_ID_serves
    ) references certx.AP_Application(AP_ID), 
    constraint AP_serves_CL_servedBy_fkCL_servedBy foreign key (
        CL_ID_servedBy
    ) references certx.CL_Client(CL_ID), 
    constraint pkAP_serves_CL_servedBy primary key (
        AP_ID_serves ,
        CL_ID_servedBy 
    )
);
-- Static tie table ---------------------------------------------------------------------------------------------------
-- AP_uses_CE_isUsedBy table (having 2 roles)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS certx.AP_uses_CE_isUsedBy (
    AP_ID_uses bigint not null, 
    CE_ID_isUsedBy bigint not null, 
    Metadata_AP_uses_CE_isUsedBy bigint not null,
    constraint AP_uses_CE_isUsedBy_fkAP_uses foreign key (
        AP_ID_uses
    ) references certx.AP_Application(AP_ID), 
    constraint AP_uses_CE_isUsedBy_fkCE_isUsedBy foreign key (
        CE_ID_isUsedBy
    ) references certx.CE_Certificate(CE_ID), 
    constraint pkAP_uses_CE_isUsedBy primary key (
        AP_ID_uses ,
        CE_ID_isUsedBy 
    )
);
-- Static tie table ---------------------------------------------------------------------------------------------------
-- CE_belongsTo_CL_owns table (having 2 roles)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS certx.CE_belongsTo_CL_owns (
    CE_ID_belongsTo bigint not null, 
    CL_ID_owns bigint not null, 
    Metadata_CE_belongsTo_CL_owns bigint not null,
    constraint CE_belongsTo_CL_owns_fkCE_belongsTo foreign key (
        CE_ID_belongsTo
    ) references certx.CE_Certificate(CE_ID), 
    constraint CE_belongsTo_CL_owns_fkCL_owns foreign key (
        CL_ID_owns
    ) references certx.CL_Client(CL_ID), 
    constraint pkCE_belongsTo_CL_owns primary key (
        CE_ID_belongsTo ,
        CL_ID_owns 
    )
);
-- Static tie table ---------------------------------------------------------------------------------------------------
-- CE_isNotifiedBy_NT_notifies table (having 2 roles)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS certx.CE_isNotifiedBy_NT_notifies (
    CE_ID_isNotifiedBy bigint not null, 
    NT_ID_notifies bigint not null, 
    Metadata_CE_isNotifiedBy_NT_notifies bigint not null,
    constraint CE_isNotifiedBy_NT_notifies_fkCE_isNotifiedBy foreign key (
        CE_ID_isNotifiedBy
    ) references certx.CE_Certificate(CE_ID), 
    constraint CE_isNotifiedBy_NT_notifies_fkNT_notifies foreign key (
        NT_ID_notifies
    ) references certx.NT_Notification(NT_ID), 
    constraint pkCE_isNotifiedBy_NT_notifies primary key (
        CE_ID_isNotifiedBy ,
        NT_ID_notifies 
    )
);
-- Static tie table ---------------------------------------------------------------------------------------------------
-- NT_sentTo_CL_receives table (having 2 roles)
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS certx.NT_sentTo_CL_receives (
    NT_ID_sentTo bigint not null, 
    CL_ID_receives bigint not null, 
    Metadata_NT_sentTo_CL_receives bigint not null,
    constraint NT_sentTo_CL_receives_fkNT_sentTo foreign key (
        NT_ID_sentTo
    ) references certx.NT_Notification(NT_ID), 
    constraint NT_sentTo_CL_receives_fkCL_receives foreign key (
        CL_ID_receives
    ) references certx.CL_Client(CL_ID), 
    constraint pkNT_sentTo_CL_receives primary key (
        NT_ID_sentTo ,
        CL_ID_receives 
    )
);
-- KNOT EQUIVALENCE VIEWS ---------------------------------------------------------------------------------------------
--
-- Equivalence views combine the identity and equivalent parts of a knot into a single view, making
-- it look and behave like a regular knot. They also make it possible to retrieve data for only the
-- given equivalent.
--
-- @equivalent the equivalent that you want to retrieve data for
--
-- ATTRIBUTE EQUIVALENCE VIEWS ----------------------------------------------------------------------------------------
--
-- Equivalence views of attributes make it possible to retrieve data for only the given equivalent.
--
-- @equivalent the equivalent that you want to retrieve data for
--
-- ATTRIBUTE RESTATEMENT CONSTRAINTS ----------------------------------------------------------------------------------
--
-- Attributes may be prevented from storing restatements.
-- A restatement is when the same value occurs for two adjacent points
-- in changing time.
--
-- returns 1 for at least one equal surrounding value, 0 for different surrounding values
--
-- @id the identity of the anchored entity
-- @eq the equivalent (when applicable)
-- @value the value of the attribute
-- @changed the point in time from which this value shall represent a change
--
-- Restatement Finder Function and Constraint -------------------------------------------------------------------------
-- rfUS_UID_User_UserId restatement finder, also used by the insert and update triggers for idempotent attributes
-- rcUS_UID_User_UserId restatement constraint (available only in attributes that cannot have restatements)
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION certx.rfUS_UID_User_UserId(
    id bigint,
    value varchar(75),
    changed timestamp
) RETURNS smallint AS '
    BEGIN
        IF EXISTS (
            SELECT
                value 
            WHERE
                value = (
                    SELECT
                        pre.US_UID_User_UserId
                    FROM
                        certx.US_UID_User_UserId pre
                    WHERE
                        pre.US_UID_US_ID = id
                    AND
                        pre.US_UID_ChangedAt < changed
                    ORDER BY
                        pre.US_UID_ChangedAt DESC
                    LIMIT 1
            )
        )
        OR EXISTS(
            SELECT
                value 
            WHERE
                value = (
                    SELECT
                        fol.US_UID_User_UserId
                    FROM
                        certx.US_UID_User_UserId fol
                    WHERE
                        fol.US_UID_US_ID = id
                    AND
                        fol.US_UID_ChangedAt > changed
                    ORDER BY
                        fol.US_UID_ChangedAt ASC
                    LIMIT 1
            )
        )
        THEN
            RETURN 1;
        END IF;
        RETURN 0;
    END;
' LANGUAGE plpgsql
;
-- Restatement Finder Function and Constraint -------------------------------------------------------------------------
-- rfUS_NAM_User_Name restatement finder, also used by the insert and update triggers for idempotent attributes
-- rcUS_NAM_User_Name restatement constraint (available only in attributes that cannot have restatements)
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION certx.rfUS_NAM_User_Name(
    id bigint,
    value varchar(75),
    changed timestamp
) RETURNS smallint AS '
    BEGIN
        IF EXISTS (
            SELECT
                value 
            WHERE
                value = (
                    SELECT
                        pre.US_NAM_User_Name
                    FROM
                        certx.US_NAM_User_Name pre
                    WHERE
                        pre.US_NAM_US_ID = id
                    AND
                        pre.US_NAM_ChangedAt < changed
                    ORDER BY
                        pre.US_NAM_ChangedAt DESC
                    LIMIT 1
            )
        )
        OR EXISTS(
            SELECT
                value 
            WHERE
                value = (
                    SELECT
                        fol.US_NAM_User_Name
                    FROM
                        certx.US_NAM_User_Name fol
                    WHERE
                        fol.US_NAM_US_ID = id
                    AND
                        fol.US_NAM_ChangedAt > changed
                    ORDER BY
                        fol.US_NAM_ChangedAt ASC
                    LIMIT 1
            )
        )
        THEN
            RETURN 1;
        END IF;
        RETURN 0;
    END;
' LANGUAGE plpgsql
;
-- Restatement Finder Function and Constraint -------------------------------------------------------------------------
-- rfAP_NAM_Application_Name restatement finder, also used by the insert and update triggers for idempotent attributes
-- rcAP_NAM_Application_Name restatement constraint (available only in attributes that cannot have restatements)
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION certx.rfAP_NAM_Application_Name(
    id bigint,
    value varchar(75),
    changed timestamp
) RETURNS smallint AS '
    BEGIN
        IF EXISTS (
            SELECT
                value 
            WHERE
                value = (
                    SELECT
                        pre.AP_NAM_Application_Name
                    FROM
                        certx.AP_NAM_Application_Name pre
                    WHERE
                        pre.AP_NAM_AP_ID = id
                    AND
                        pre.AP_NAM_ChangedAt < changed
                    ORDER BY
                        pre.AP_NAM_ChangedAt DESC
                    LIMIT 1
            )
        )
        OR EXISTS(
            SELECT
                value 
            WHERE
                value = (
                    SELECT
                        fol.AP_NAM_Application_Name
                    FROM
                        certx.AP_NAM_Application_Name fol
                    WHERE
                        fol.AP_NAM_AP_ID = id
                    AND
                        fol.AP_NAM_ChangedAt > changed
                    ORDER BY
                        fol.AP_NAM_ChangedAt ASC
                    LIMIT 1
            )
        )
        THEN
            RETURN 1;
        END IF;
        RETURN 0;
    END;
' LANGUAGE plpgsql
;
-- Restatement Finder Function and Constraint -------------------------------------------------------------------------
-- rfCL_EID_Client_Email restatement finder, also used by the insert and update triggers for idempotent attributes
-- rcCL_EID_Client_Email restatement constraint (available only in attributes that cannot have restatements)
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION certx.rfCL_EID_Client_Email(
    id bigint,
    value varchar(100),
    changed timestamp
) RETURNS smallint AS '
    BEGIN
        IF EXISTS (
            SELECT
                value 
            WHERE
                value = (
                    SELECT
                        pre.CL_EID_Client_Email
                    FROM
                        certx.CL_EID_Client_Email pre
                    WHERE
                        pre.CL_EID_CL_ID = id
                    AND
                        pre.CL_EID_ChangedAt < changed
                    ORDER BY
                        pre.CL_EID_ChangedAt DESC
                    LIMIT 1
            )
        )
        OR EXISTS(
            SELECT
                value 
            WHERE
                value = (
                    SELECT
                        fol.CL_EID_Client_Email
                    FROM
                        certx.CL_EID_Client_Email fol
                    WHERE
                        fol.CL_EID_CL_ID = id
                    AND
                        fol.CL_EID_ChangedAt > changed
                    ORDER BY
                        fol.CL_EID_ChangedAt ASC
                    LIMIT 1
            )
        )
        THEN
            RETURN 1;
        END IF;
        RETURN 0;
    END;
' LANGUAGE plpgsql
;
-- Restatement Finder Function and Constraint -------------------------------------------------------------------------
-- rfCL_MNO_Client_MobileNumber restatement finder, also used by the insert and update triggers for idempotent attributes
-- rcCL_MNO_Client_MobileNumber restatement constraint (available only in attributes that cannot have restatements)
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION certx.rfCL_MNO_Client_MobileNumber(
    id bigint,
    value varchar(12),
    changed timestamp
) RETURNS smallint AS '
    BEGIN
        IF EXISTS (
            SELECT
                value 
            WHERE
                value = (
                    SELECT
                        pre.CL_MNO_Client_MobileNumber
                    FROM
                        certx.CL_MNO_Client_MobileNumber pre
                    WHERE
                        pre.CL_MNO_CL_ID = id
                    AND
                        pre.CL_MNO_ChangedAt < changed
                    ORDER BY
                        pre.CL_MNO_ChangedAt DESC
                    LIMIT 1
            )
        )
        OR EXISTS(
            SELECT
                value 
            WHERE
                value = (
                    SELECT
                        fol.CL_MNO_Client_MobileNumber
                    FROM
                        certx.CL_MNO_Client_MobileNumber fol
                    WHERE
                        fol.CL_MNO_CL_ID = id
                    AND
                        fol.CL_MNO_ChangedAt > changed
                    ORDER BY
                        fol.CL_MNO_ChangedAt ASC
                    LIMIT 1
            )
        )
        THEN
            RETURN 1;
        END IF;
        RETURN 0;
    END;
' LANGUAGE plpgsql
;
-- KEY GENERATORS -----------------------------------------------------------------------------------------------------
--
-- These stored procedures can be used to generate identities of entities.
-- Corresponding anchors must have an incrementing identity column.
--
-- Key Generation Stored Procedure ------------------------------------------------------------------------------------
-- kUS_User identity by surrogate key generation stored procedure
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION certx.kUS_User(
    requestedNumberOfIdentities bigint,
    metadata bigint
) RETURNS void AS '
    BEGIN
        IF requestedNumberOfIdentities > 0
        THEN
            INSERT INTO certx.US_User (
                Metadata_US
            )
            SELECT
                metadata
            FROM
                generate_series(1,requestedNumberOfIdentities);
        END IF;
    END;
' LANGUAGE plpgsql
;
-- Key Generation Stored Procedure ------------------------------------------------------------------------------------
-- kRO_Role identity by surrogate key generation stored procedure
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION certx.kRO_Role(
    requestedNumberOfIdentities bigint,
    metadata bigint
) RETURNS void AS '
    BEGIN
        IF requestedNumberOfIdentities > 0
        THEN
            INSERT INTO certx.RO_Role (
                Metadata_RO
            )
            SELECT
                metadata
            FROM
                generate_series(1,requestedNumberOfIdentities);
        END IF;
    END;
' LANGUAGE plpgsql
;
-- Key Generation Stored Procedure ------------------------------------------------------------------------------------
-- kAP_Application identity by surrogate key generation stored procedure
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION certx.kAP_Application(
    requestedNumberOfIdentities bigint,
    metadata bigint
) RETURNS void AS '
    BEGIN
        IF requestedNumberOfIdentities > 0
        THEN
            INSERT INTO certx.AP_Application (
                Metadata_AP
            )
            SELECT
                metadata
            FROM
                generate_series(1,requestedNumberOfIdentities);
        END IF;
    END;
' LANGUAGE plpgsql
;
-- Key Generation Stored Procedure ------------------------------------------------------------------------------------
-- kCL_Client identity by surrogate key generation stored procedure
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION certx.kCL_Client(
    requestedNumberOfIdentities bigint,
    metadata bigint
) RETURNS void AS '
    BEGIN
        IF requestedNumberOfIdentities > 0
        THEN
            INSERT INTO certx.CL_Client (
                Metadata_CL
            )
            SELECT
                metadata
            FROM
                generate_series(1,requestedNumberOfIdentities);
        END IF;
    END;
' LANGUAGE plpgsql
;
-- Key Generation Stored Procedure ------------------------------------------------------------------------------------
-- kCE_Certificate identity by surrogate key generation stored procedure
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION certx.kCE_Certificate(
    requestedNumberOfIdentities bigint,
    metadata bigint
) RETURNS void AS '
    BEGIN
        IF requestedNumberOfIdentities > 0
        THEN
            INSERT INTO certx.CE_Certificate (
                Metadata_CE
            )
            SELECT
                metadata
            FROM
                generate_series(1,requestedNumberOfIdentities);
        END IF;
    END;
' LANGUAGE plpgsql
;
-- Key Generation Stored Procedure ------------------------------------------------------------------------------------
-- kNT_Notification identity by surrogate key generation stored procedure
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE FUNCTION certx.kNT_Notification(
    requestedNumberOfIdentities bigint,
    metadata bigint
) RETURNS void AS '
    BEGIN
        IF requestedNumberOfIdentities > 0
        THEN
            INSERT INTO certx.NT_Notification (
                Metadata_NT
            )
            SELECT
                metadata
            FROM
                generate_series(1,requestedNumberOfIdentities);
        END IF;
    END;
' LANGUAGE plpgsql
;
-- ATTRIBUTE TEMPORAL PERSPECTIVES ---------------------------------------------------------------------------------------
--
-- These table valued functions simplify temporal querying by providing a temporal
-- perspective of each attribute. There are three types of perspectives: latest,
-- point-in-time and now. 
--
-- The latest perspective shows the latest available information for each attribute.
-- The now perspective shows the information as it is right now.
-- The point-in-time perspective lets you travel through the information to the given timepoint.
--
-- @changingTimepoint the point in changing time to travel to
--
-- Under equivalence all these views default to equivalent = 0, however, corresponding
-- prepended-e perspectives are provided in order to select a specific equivalent.
--
-- @equivalent the equivalent for which to retrieve data
--
-- Latest perspective -------------------------------------------------------------------------------------------------
-- lUS_UID_User_UserId viewed by the latest available information (may include future versions)
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW certx.lUS_UID_User_UserId AS
SELECT DISTINCT ON (US_UID_US_ID) US_UID_US_ID
     , US_UID_User_UserId
     , US_UID_ChangedAt
     , Metadata_US_UID
  FROM certx.US_UID_User_UserId
 ORDER 
    BY US_UID_US_ID DESC
     , US_UID_ChangedAt DESC 
;
-- Attribute Point-in-time perspective -------------------------------------------------------------------------------------------------
-- pUS_UID_User_UserId viewed as it was on the given timepoint
-----------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION certx.pUS_UID_User_UserId
      ( changingTimepoint timestamp
      ) 
RETURNS TABLE
      ( US_UID_US_ID bigint
      , US_UID_User_UserId varchar(75)
      , US_UID_ChangedAt timestamp 
      , Metadata_US_UID bigint
      ) 
AS 
'
 SELECT DISTINCT ON (US_UID_US_ID) US_UID_US_ID
      , US_UID_User_UserId
      , US_UID_ChangedAt
      , Metadata_US_UID
   FROM certx.US_UID_User_UserId
  WHERE US_UID_ChangedAt <= changingTimepoint
  ORDER 
     BY US_UID_US_ID DESC
      , US_UID_ChangedAt DESC 
 ;
' 
LANGUAGE SQL STABLE
;
-- Now perspective ----------------------------------------------------------------------------------------------------
-- nUS_UID_User_UserId viewed as it currently is (cannot include future versions)
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW certx.nUS_UID_User_UserId AS
SELECT *
  FROM certx.pUS_UID_User_UserId(now()::timestamp)
;
-- Latest perspective -------------------------------------------------------------------------------------------------
-- lUS_NAM_User_Name viewed by the latest available information (may include future versions)
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW certx.lUS_NAM_User_Name AS
SELECT DISTINCT ON (US_NAM_US_ID) US_NAM_US_ID
     , US_NAM_User_Name
     , US_NAM_ChangedAt
     , Metadata_US_NAM
  FROM certx.US_NAM_User_Name
 ORDER 
    BY US_NAM_US_ID DESC
     , US_NAM_ChangedAt DESC 
;
-- Attribute Point-in-time perspective -------------------------------------------------------------------------------------------------
-- pUS_NAM_User_Name viewed as it was on the given timepoint
-----------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION certx.pUS_NAM_User_Name
      ( changingTimepoint timestamp
      ) 
RETURNS TABLE
      ( US_NAM_US_ID bigint
      , US_NAM_User_Name varchar(75)
      , US_NAM_ChangedAt timestamp 
      , Metadata_US_NAM bigint
      ) 
AS 
'
 SELECT DISTINCT ON (US_NAM_US_ID) US_NAM_US_ID
      , US_NAM_User_Name
      , US_NAM_ChangedAt
      , Metadata_US_NAM
   FROM certx.US_NAM_User_Name
  WHERE US_NAM_ChangedAt <= changingTimepoint
  ORDER 
     BY US_NAM_US_ID DESC
      , US_NAM_ChangedAt DESC 
 ;
' 
LANGUAGE SQL STABLE
;
-- Now perspective ----------------------------------------------------------------------------------------------------
-- nUS_NAM_User_Name viewed as it currently is (cannot include future versions)
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW certx.nUS_NAM_User_Name AS
SELECT *
  FROM certx.pUS_NAM_User_Name(now()::timestamp)
;
-- Latest perspective -------------------------------------------------------------------------------------------------
-- lAP_NAM_Application_Name viewed by the latest available information (may include future versions)
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW certx.lAP_NAM_Application_Name AS
SELECT DISTINCT ON (AP_NAM_AP_ID) AP_NAM_AP_ID
     , AP_NAM_Application_Name
     , AP_NAM_ChangedAt
     , Metadata_AP_NAM
  FROM certx.AP_NAM_Application_Name
 ORDER 
    BY AP_NAM_AP_ID DESC
     , AP_NAM_ChangedAt DESC 
;
-- Attribute Point-in-time perspective -------------------------------------------------------------------------------------------------
-- pAP_NAM_Application_Name viewed as it was on the given timepoint
-----------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION certx.pAP_NAM_Application_Name
      ( changingTimepoint timestamp
      ) 
RETURNS TABLE
      ( AP_NAM_AP_ID bigint
      , AP_NAM_Application_Name varchar(75)
      , AP_NAM_ChangedAt timestamp 
      , Metadata_AP_NAM bigint
      ) 
AS 
'
 SELECT DISTINCT ON (AP_NAM_AP_ID) AP_NAM_AP_ID
      , AP_NAM_Application_Name
      , AP_NAM_ChangedAt
      , Metadata_AP_NAM
   FROM certx.AP_NAM_Application_Name
  WHERE AP_NAM_ChangedAt <= changingTimepoint
  ORDER 
     BY AP_NAM_AP_ID DESC
      , AP_NAM_ChangedAt DESC 
 ;
' 
LANGUAGE SQL STABLE
;
-- Now perspective ----------------------------------------------------------------------------------------------------
-- nAP_NAM_Application_Name viewed as it currently is (cannot include future versions)
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW certx.nAP_NAM_Application_Name AS
SELECT *
  FROM certx.pAP_NAM_Application_Name(now()::timestamp)
;
-- Latest perspective -------------------------------------------------------------------------------------------------
-- lCL_EID_Client_Email viewed by the latest available information (may include future versions)
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW certx.lCL_EID_Client_Email AS
SELECT DISTINCT ON (CL_EID_CL_ID) CL_EID_CL_ID
     , CL_EID_Client_Email
     , CL_EID_ChangedAt
     , Metadata_CL_EID
  FROM certx.CL_EID_Client_Email
 ORDER 
    BY CL_EID_CL_ID DESC
     , CL_EID_ChangedAt DESC 
;
-- Attribute Point-in-time perspective -------------------------------------------------------------------------------------------------
-- pCL_EID_Client_Email viewed as it was on the given timepoint
-----------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION certx.pCL_EID_Client_Email
      ( changingTimepoint timestamp
      ) 
RETURNS TABLE
      ( CL_EID_CL_ID bigint
      , CL_EID_Client_Email varchar(100)
      , CL_EID_ChangedAt timestamp 
      , Metadata_CL_EID bigint
      ) 
AS 
'
 SELECT DISTINCT ON (CL_EID_CL_ID) CL_EID_CL_ID
      , CL_EID_Client_Email
      , CL_EID_ChangedAt
      , Metadata_CL_EID
   FROM certx.CL_EID_Client_Email
  WHERE CL_EID_ChangedAt <= changingTimepoint
  ORDER 
     BY CL_EID_CL_ID DESC
      , CL_EID_ChangedAt DESC 
 ;
' 
LANGUAGE SQL STABLE
;
-- Now perspective ----------------------------------------------------------------------------------------------------
-- nCL_EID_Client_Email viewed as it currently is (cannot include future versions)
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW certx.nCL_EID_Client_Email AS
SELECT *
  FROM certx.pCL_EID_Client_Email(now()::timestamp)
;
-- Latest perspective -------------------------------------------------------------------------------------------------
-- lCL_MNO_Client_MobileNumber viewed by the latest available information (may include future versions)
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW certx.lCL_MNO_Client_MobileNumber AS
SELECT DISTINCT ON (CL_MNO_CL_ID) CL_MNO_CL_ID
     , CL_MNO_Client_MobileNumber
     , CL_MNO_ChangedAt
     , Metadata_CL_MNO
  FROM certx.CL_MNO_Client_MobileNumber
 ORDER 
    BY CL_MNO_CL_ID DESC
     , CL_MNO_ChangedAt DESC 
;
-- Attribute Point-in-time perspective -------------------------------------------------------------------------------------------------
-- pCL_MNO_Client_MobileNumber viewed as it was on the given timepoint
-----------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION certx.pCL_MNO_Client_MobileNumber
      ( changingTimepoint timestamp
      ) 
RETURNS TABLE
      ( CL_MNO_CL_ID bigint
      , CL_MNO_Client_MobileNumber varchar(12)
      , CL_MNO_ChangedAt timestamp 
      , Metadata_CL_MNO bigint
      ) 
AS 
'
 SELECT DISTINCT ON (CL_MNO_CL_ID) CL_MNO_CL_ID
      , CL_MNO_Client_MobileNumber
      , CL_MNO_ChangedAt
      , Metadata_CL_MNO
   FROM certx.CL_MNO_Client_MobileNumber
  WHERE CL_MNO_ChangedAt <= changingTimepoint
  ORDER 
     BY CL_MNO_CL_ID DESC
      , CL_MNO_ChangedAt DESC 
 ;
' 
LANGUAGE SQL STABLE
;
-- Now perspective ----------------------------------------------------------------------------------------------------
-- nCL_MNO_Client_MobileNumber viewed as it currently is (cannot include future versions)
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW certx.nCL_MNO_Client_MobileNumber AS
SELECT *
  FROM certx.pCL_MNO_Client_MobileNumber(now()::timestamp)
;
-- ANCHOR TEMPORAL PERSPECTIVES ---------------------------------------------------------------------------------------
--
-- These table valued functions simplify temporal querying by providing a temporal
-- perspective of each anchor. There are four types of perspectives: latest,
-- point-in-time, difference, and now. They also denormalize the anchor, its attributes,
-- and referenced knots from sixth to third normal form.
--
-- The latest perspective shows the latest available information for each anchor.
-- The now perspective shows the information as it is right now.
-- The point-in-time perspective lets you travel through the information to the given timepoint.
--
-- @changingTimepoint the point in changing time to travel to
--
-- The difference perspective shows changes between the two given timepoints, and for
-- changes in all or a selection of attributes.
--
-- @intervalStart the start of the interval for finding changes
-- @intervalEnd the end of the interval for finding changes
-- @selection a list of mnemonics for tracked attributes, ie 'MNE MON ICS', or null for all
--
-- Under equivalence all these views default to equivalent = 0, however, corresponding
-- prepended-e perspectives are provided in order to select a specific equivalent.
--
-- @equivalent the equivalent for which to retrieve data
--
-- Latest perspective -------------------------------------------------------------------------------------------------
-- lUS_User viewed by the latest available information (may include future versions)
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW certx.lUS_User AS
SELECT US.US_ID
     , US.Metadata_US
     , UID.US_UID_US_ID
     , UID.Metadata_US_UID
     , UID.US_UID_ChangedAt
     , UID.US_UID_User_UserId
     , NAM.US_NAM_US_ID
     , NAM.Metadata_US_NAM
     , NAM.US_NAM_ChangedAt
     , NAM.US_NAM_User_Name
  FROM certx.US_User US
  LEFT 
  JOIN certx.lUS_UID_User_UserId UID
    ON UID.US_UID_US_ID = US.US_ID
  LEFT 
  JOIN certx.lUS_NAM_User_Name NAM
    ON NAM.US_NAM_US_ID = US.US_ID;
;
-- Point-in-time perspective ------------------------------------------------------------------------------------------
-- pUS_User viewed as it was on the given timepoint
-----------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION certx.pUS_User 
      ( changingTimepoint timestamp
      )
RETURNS TABLE 
      ( US_ID bigint
      , Metadata_US bigint
      , US_UID_US_ID bigint
      , Metadata_US_UID bigint
      , US_UID_ChangedAt timestamp
      , US_UID_User_UserId varchar(75)
      , US_NAM_US_ID bigint
      , Metadata_US_NAM bigint
      , US_NAM_ChangedAt timestamp
      , US_NAM_User_Name varchar(75)
      ) 
AS 
'
 SELECT US.US_ID
      , US.Metadata_US
      , UID.US_UID_US_ID
      , UID.Metadata_US_UID
      , UID.US_UID_ChangedAt
      , UID.US_UID_User_UserId
      , NAM.US_NAM_US_ID
      , NAM.Metadata_US_NAM
      , NAM.US_NAM_ChangedAt
      , NAM.US_NAM_User_Name
   FROM certx.US_User US
   LEFT 
   JOIN certx.pUS_UID_User_UserId(changingTimepoint) UID
     ON UID.US_UID_US_ID = US.US_ID
   LEFT 
   JOIN certx.pUS_NAM_User_Name(changingTimepoint) NAM
     ON NAM.US_NAM_US_ID = US.US_ID
;
' 
LANGUAGE SQL STABLE
;
-- Now perspective ----------------------------------------------------------------------------------------------------
-- nUS_User viewed as it currently is (cannot include future versions)
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW certx.nUS_User
AS
SELECT *
  FROM certx.pUS_User(now()::timestamp)
;
-- Difference perspective ---------------------------------------------------------------------------------------------
-- dUS_User showing all differences between the given timepoints and optionally for a subset of attributes
-----------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION certx.dUS_User 
      ( intervalStart timestamp,
        intervalEnd timestamp,
        selection text = null
      )
RETURNS TABLE 
      ( inspectedTimepoint timestamp
      , mnemonic text
      , US_ID bigint
      , Metadata_US bigint
      , US_UID_US_ID bigint
      , Metadata_US_UID bigint
      , US_UID_ChangedAt timestamp
      , US_UID_User_UserId varchar(75)
      , US_NAM_US_ID bigint
      , Metadata_US_NAM bigint
      , US_NAM_ChangedAt timestamp
      , US_NAM_User_Name varchar(75)
      ) 
AS 
'
 SELECT timepoints.inspectedTimepoint
      , timepoints.mnemonic
      , pUS.*
   FROM (
          SELECT DISTINCT US_UID_US_ID AS US_ID
               , US_UID_ChangedAt::timestamp inspectedTimepoint
               , ''UID'' AS mnemonic
            FROM certx.US_UID_User_UserId
           WHERE (selection is null OR selection like ''%UID%'')
             AND US_UID_ChangedAt BETWEEN intervalStart AND intervalEnd
           UNION
          SELECT DISTINCT US_NAM_US_ID AS US_ID
               , US_NAM_ChangedAt::timestamp inspectedTimepoint
               , ''NAM'' AS mnemonic
            FROM certx.US_NAM_User_Name
           WHERE (selection is null OR selection like ''%NAM%'')
             AND US_NAM_ChangedAt BETWEEN intervalStart AND intervalEnd
        ) timepoints
  CROSS 
   JOIN LATERAL certx.pUS_User(timepoints.inspectedTimepoint) pUS
  WHERE pUS.US_ID = timepoints.US_ID;
' 
LANGUAGE SQL STABLE
;
-- Latest perspective -------------------------------------------------------------------------------------------------
-- lRO_Role viewed by the latest available information (may include future versions)
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW certx.lRO_Role AS
SELECT RO.RO_ID
     , RO.Metadata_RO
     , NAM.RO_NAM_RO_ID
     , NAM.Metadata_RO_NAM
     , NAM.RO_NAM_Role_Name
  FROM certx.RO_Role RO
  LEFT 
  JOIN certx.RO_NAM_Role_Name NAM
    ON NAM.RO_NAM_RO_ID = RO.RO_ID;
;
-- Point-in-time perspective ------------------------------------------------------------------------------------------
-- pRO_Role viewed as it was on the given timepoint
-----------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION certx.pRO_Role 
      ( changingTimepoint timestamp
      )
RETURNS TABLE 
      ( RO_ID bigint
      , Metadata_RO bigint
      , RO_NAM_RO_ID bigint
      , Metadata_RO_NAM bigint
      , RO_NAM_Role_Name varchar(75)
      ) 
AS 
'
 SELECT RO.RO_ID
      , RO.Metadata_RO
      , NAM.RO_NAM_RO_ID
      , NAM.Metadata_RO_NAM
      , NAM.RO_NAM_Role_Name
   FROM certx.RO_Role RO
   LEFT 
   JOIN certx.RO_NAM_Role_Name NAM
     ON NAM.RO_NAM_RO_ID = RO.RO_ID;
' 
LANGUAGE SQL STABLE
;
-- Now perspective ----------------------------------------------------------------------------------------------------
-- nRO_Role viewed as it currently is (cannot include future versions)
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW certx.nRO_Role
AS
SELECT *
  FROM certx.pRO_Role(now()::timestamp)
;
-- Latest perspective -------------------------------------------------------------------------------------------------
-- lAP_Application viewed by the latest available information (may include future versions)
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW certx.lAP_Application AS
SELECT AP.AP_ID
     , AP.Metadata_AP
     , NAM.AP_NAM_AP_ID
     , NAM.Metadata_AP_NAM
     , NAM.AP_NAM_ChangedAt
     , NAM.AP_NAM_Application_Name
     , UID.AP_UID_AP_ID
     , UID.Metadata_AP_UID
     , UID.AP_UID_Application_UniqueId
  FROM certx.AP_Application AP
  LEFT 
  JOIN certx.lAP_NAM_Application_Name NAM
    ON NAM.AP_NAM_AP_ID = AP.AP_ID
  LEFT 
  JOIN certx.AP_UID_Application_UniqueId UID
    ON UID.AP_UID_AP_ID = AP.AP_ID;
;
-- Point-in-time perspective ------------------------------------------------------------------------------------------
-- pAP_Application viewed as it was on the given timepoint
-----------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION certx.pAP_Application 
      ( changingTimepoint timestamp
      )
RETURNS TABLE 
      ( AP_ID bigint
      , Metadata_AP bigint
      , AP_NAM_AP_ID bigint
      , Metadata_AP_NAM bigint
      , AP_NAM_ChangedAt timestamp
      , AP_NAM_Application_Name varchar(75)
      , AP_UID_AP_ID bigint
      , Metadata_AP_UID bigint
      , AP_UID_Application_UniqueId varchar(15)
      ) 
AS 
'
 SELECT AP.AP_ID
      , AP.Metadata_AP
      , NAM.AP_NAM_AP_ID
      , NAM.Metadata_AP_NAM
      , NAM.AP_NAM_ChangedAt
      , NAM.AP_NAM_Application_Name
      , UID.AP_UID_AP_ID
      , UID.Metadata_AP_UID
      , UID.AP_UID_Application_UniqueId
   FROM certx.AP_Application AP
   LEFT 
   JOIN certx.pAP_NAM_Application_Name(changingTimepoint) NAM
     ON NAM.AP_NAM_AP_ID = AP.AP_ID
   LEFT 
   JOIN certx.AP_UID_Application_UniqueId UID
     ON UID.AP_UID_AP_ID = AP.AP_ID;
' 
LANGUAGE SQL STABLE
;
-- Now perspective ----------------------------------------------------------------------------------------------------
-- nAP_Application viewed as it currently is (cannot include future versions)
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW certx.nAP_Application
AS
SELECT *
  FROM certx.pAP_Application(now()::timestamp)
;
-- Difference perspective ---------------------------------------------------------------------------------------------
-- dAP_Application showing all differences between the given timepoints and optionally for a subset of attributes
-----------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION certx.dAP_Application 
      ( intervalStart timestamp,
        intervalEnd timestamp,
        selection text = null
      )
RETURNS TABLE 
      ( inspectedTimepoint timestamp
      , mnemonic text
      , AP_ID bigint
      , Metadata_AP bigint
      , AP_NAM_AP_ID bigint
      , Metadata_AP_NAM bigint
      , AP_NAM_ChangedAt timestamp
      , AP_NAM_Application_Name varchar(75)
      , AP_UID_AP_ID bigint
      , Metadata_AP_UID bigint
      , AP_UID_Application_UniqueId varchar(15)
      ) 
AS 
'
 SELECT timepoints.inspectedTimepoint
      , timepoints.mnemonic
      , pAP.*
   FROM (
          SELECT DISTINCT AP_NAM_AP_ID AS AP_ID
               , AP_NAM_ChangedAt::timestamp inspectedTimepoint
               , ''NAM'' AS mnemonic
            FROM certx.AP_NAM_Application_Name
           WHERE (selection is null OR selection like ''%NAM%'')
             AND AP_NAM_ChangedAt BETWEEN intervalStart AND intervalEnd
        ) timepoints
  CROSS 
   JOIN LATERAL certx.pAP_Application(timepoints.inspectedTimepoint) pAP
  WHERE pAP.AP_ID = timepoints.AP_ID;
' 
LANGUAGE SQL STABLE
;
-- Latest perspective -------------------------------------------------------------------------------------------------
-- lCL_Client viewed by the latest available information (may include future versions)
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW certx.lCL_Client AS
SELECT CL.CL_ID
     , CL.Metadata_CL
     , NAM.CL_NAM_CL_ID
     , NAM.Metadata_CL_NAM
     , NAM.CL_NAM_Client_Name
     , EID.CL_EID_CL_ID
     , EID.Metadata_CL_EID
     , EID.CL_EID_ChangedAt
     , EID.CL_EID_Client_Email
     , MNO.CL_MNO_CL_ID
     , MNO.Metadata_CL_MNO
     , MNO.CL_MNO_ChangedAt
     , MNO.CL_MNO_Client_MobileNumber
  FROM certx.CL_Client CL
  LEFT 
  JOIN certx.CL_NAM_Client_Name NAM
    ON NAM.CL_NAM_CL_ID = CL.CL_ID
  LEFT 
  JOIN certx.lCL_EID_Client_Email EID
    ON EID.CL_EID_CL_ID = CL.CL_ID
  LEFT 
  JOIN certx.lCL_MNO_Client_MobileNumber MNO
    ON MNO.CL_MNO_CL_ID = CL.CL_ID;
;
-- Point-in-time perspective ------------------------------------------------------------------------------------------
-- pCL_Client viewed as it was on the given timepoint
-----------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION certx.pCL_Client 
      ( changingTimepoint timestamp
      )
RETURNS TABLE 
      ( CL_ID bigint
      , Metadata_CL bigint
      , CL_NAM_CL_ID bigint
      , Metadata_CL_NAM bigint
      , CL_NAM_Client_Name varchar(75)
      , CL_EID_CL_ID bigint
      , Metadata_CL_EID bigint
      , CL_EID_ChangedAt timestamp
      , CL_EID_Client_Email varchar(100)
      , CL_MNO_CL_ID bigint
      , Metadata_CL_MNO bigint
      , CL_MNO_ChangedAt timestamp
      , CL_MNO_Client_MobileNumber varchar(12)
      ) 
AS 
'
 SELECT CL.CL_ID
      , CL.Metadata_CL
      , NAM.CL_NAM_CL_ID
      , NAM.Metadata_CL_NAM
      , NAM.CL_NAM_Client_Name
      , EID.CL_EID_CL_ID
      , EID.Metadata_CL_EID
      , EID.CL_EID_ChangedAt
      , EID.CL_EID_Client_Email
      , MNO.CL_MNO_CL_ID
      , MNO.Metadata_CL_MNO
      , MNO.CL_MNO_ChangedAt
      , MNO.CL_MNO_Client_MobileNumber
   FROM certx.CL_Client CL
   LEFT 
   JOIN certx.CL_NAM_Client_Name NAM
     ON NAM.CL_NAM_CL_ID = CL.CL_ID
   LEFT 
   JOIN certx.pCL_EID_Client_Email(changingTimepoint) EID
     ON EID.CL_EID_CL_ID = CL.CL_ID
   LEFT 
   JOIN certx.pCL_MNO_Client_MobileNumber(changingTimepoint) MNO
     ON MNO.CL_MNO_CL_ID = CL.CL_ID
;
' 
LANGUAGE SQL STABLE
;
-- Now perspective ----------------------------------------------------------------------------------------------------
-- nCL_Client viewed as it currently is (cannot include future versions)
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW certx.nCL_Client
AS
SELECT *
  FROM certx.pCL_Client(now()::timestamp)
;
-- Difference perspective ---------------------------------------------------------------------------------------------
-- dCL_Client showing all differences between the given timepoints and optionally for a subset of attributes
-----------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION certx.dCL_Client 
      ( intervalStart timestamp,
        intervalEnd timestamp,
        selection text = null
      )
RETURNS TABLE 
      ( inspectedTimepoint timestamp
      , mnemonic text
      , CL_ID bigint
      , Metadata_CL bigint
      , CL_NAM_CL_ID bigint
      , Metadata_CL_NAM bigint
      , CL_NAM_Client_Name varchar(75)
      , CL_EID_CL_ID bigint
      , Metadata_CL_EID bigint
      , CL_EID_ChangedAt timestamp
      , CL_EID_Client_Email varchar(100)
      , CL_MNO_CL_ID bigint
      , Metadata_CL_MNO bigint
      , CL_MNO_ChangedAt timestamp
      , CL_MNO_Client_MobileNumber varchar(12)
      ) 
AS 
'
 SELECT timepoints.inspectedTimepoint
      , timepoints.mnemonic
      , pCL.*
   FROM (
          SELECT DISTINCT CL_EID_CL_ID AS CL_ID
               , CL_EID_ChangedAt::timestamp inspectedTimepoint
               , ''EID'' AS mnemonic
            FROM certx.CL_EID_Client_Email
           WHERE (selection is null OR selection like ''%EID%'')
             AND CL_EID_ChangedAt BETWEEN intervalStart AND intervalEnd
           UNION
          SELECT DISTINCT CL_MNO_CL_ID AS CL_ID
               , CL_MNO_ChangedAt::timestamp inspectedTimepoint
               , ''MNO'' AS mnemonic
            FROM certx.CL_MNO_Client_MobileNumber
           WHERE (selection is null OR selection like ''%MNO%'')
             AND CL_MNO_ChangedAt BETWEEN intervalStart AND intervalEnd
        ) timepoints
  CROSS 
   JOIN LATERAL certx.pCL_Client(timepoints.inspectedTimepoint) pCL
  WHERE pCL.CL_ID = timepoints.CL_ID;
' 
LANGUAGE SQL STABLE
;
-- Latest perspective -------------------------------------------------------------------------------------------------
-- lCE_Certificate viewed by the latest available information (may include future versions)
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW certx.lCE_Certificate AS
SELECT CE.CE_ID
     , CE.Metadata_CE
     , ION.CE_ION_CE_ID
     , ION.Metadata_CE_ION
     , ION.CE_ION_Certificate_IssuedOn
     , RON.CE_RON_CE_ID
     , RON.Metadata_CE_RON
     , RON.CE_RON_Certificate_RevokedOn
     , SNO.CE_SNO_CE_ID
     , SNO.Metadata_CE_SNO
     , SNO.CE_SNO_Certificate_SerialNumber
     , LTV.CE_LTV_CE_ID
     , LTV.Metadata_CE_LTV
     , LTV.CE_LTV_Certificate_LastTimeVerifiedOn
     , CEP.CE_CEP_CE_ID
     , CEP.Metadata_CE_CEP
     , CEP.CE_CEP_Certificate_CertificatePath
     , NAF.CE_NAF_CE_ID
     , NAF.Metadata_CE_NAF
     , NAF.CE_NAF_Certificate_NotAfter
  FROM certx.CE_Certificate CE
  LEFT 
  JOIN certx.CE_ION_Certificate_IssuedOn ION
    ON ION.CE_ION_CE_ID = CE.CE_ID
  LEFT 
  JOIN certx.CE_RON_Certificate_RevokedOn RON
    ON RON.CE_RON_CE_ID = CE.CE_ID
  LEFT 
  JOIN certx.CE_SNO_Certificate_SerialNumber SNO
    ON SNO.CE_SNO_CE_ID = CE.CE_ID
  LEFT 
  JOIN certx.CE_LTV_Certificate_LastTimeVerifiedOn LTV
    ON LTV.CE_LTV_CE_ID = CE.CE_ID
  LEFT 
  JOIN certx.CE_CEP_Certificate_CertificatePath CEP
    ON CEP.CE_CEP_CE_ID = CE.CE_ID
  LEFT 
  JOIN certx.CE_NAF_Certificate_NotAfter NAF
    ON NAF.CE_NAF_CE_ID = CE.CE_ID;
;
-- Point-in-time perspective ------------------------------------------------------------------------------------------
-- pCE_Certificate viewed as it was on the given timepoint
-----------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION certx.pCE_Certificate 
      ( changingTimepoint timestamp
      )
RETURNS TABLE 
      ( CE_ID bigint
      , Metadata_CE bigint
      , CE_ION_CE_ID bigint
      , Metadata_CE_ION bigint
      , CE_ION_Certificate_IssuedOn timestamp with time zone
      , CE_RON_CE_ID bigint
      , Metadata_CE_RON bigint
      , CE_RON_Certificate_RevokedOn timestamp with time zone
      , CE_SNO_CE_ID bigint
      , Metadata_CE_SNO bigint
      , CE_SNO_Certificate_SerialNumber varchar(25)
      , CE_LTV_CE_ID bigint
      , Metadata_CE_LTV bigint
      , CE_LTV_Certificate_LastTimeVerifiedOn timestamp with time zone
      , CE_CEP_CE_ID bigint
      , Metadata_CE_CEP bigint
      , CE_CEP_Certificate_CertificatePath text
      , CE_NAF_CE_ID bigint
      , Metadata_CE_NAF bigint
      , CE_NAF_Certificate_NotAfter timestamp with time zone
      ) 
AS 
'
 SELECT CE.CE_ID
      , CE.Metadata_CE
      , ION.CE_ION_CE_ID
      , ION.Metadata_CE_ION
      , ION.CE_ION_Certificate_IssuedOn
      , RON.CE_RON_CE_ID
      , RON.Metadata_CE_RON
      , RON.CE_RON_Certificate_RevokedOn
      , SNO.CE_SNO_CE_ID
      , SNO.Metadata_CE_SNO
      , SNO.CE_SNO_Certificate_SerialNumber
      , LTV.CE_LTV_CE_ID
      , LTV.Metadata_CE_LTV
      , LTV.CE_LTV_Certificate_LastTimeVerifiedOn
      , CEP.CE_CEP_CE_ID
      , CEP.Metadata_CE_CEP
      , CEP.CE_CEP_Certificate_CertificatePath
      , NAF.CE_NAF_CE_ID
      , NAF.Metadata_CE_NAF
      , NAF.CE_NAF_Certificate_NotAfter
   FROM certx.CE_Certificate CE
   LEFT 
   JOIN certx.CE_ION_Certificate_IssuedOn ION
     ON ION.CE_ION_CE_ID = CE.CE_ID
   LEFT 
   JOIN certx.CE_RON_Certificate_RevokedOn RON
     ON RON.CE_RON_CE_ID = CE.CE_ID
   LEFT 
   JOIN certx.CE_SNO_Certificate_SerialNumber SNO
     ON SNO.CE_SNO_CE_ID = CE.CE_ID
   LEFT 
   JOIN certx.CE_LTV_Certificate_LastTimeVerifiedOn LTV
     ON LTV.CE_LTV_CE_ID = CE.CE_ID
   LEFT 
   JOIN certx.CE_CEP_Certificate_CertificatePath CEP
     ON CEP.CE_CEP_CE_ID = CE.CE_ID
   LEFT 
   JOIN certx.CE_NAF_Certificate_NotAfter NAF
     ON NAF.CE_NAF_CE_ID = CE.CE_ID;
' 
LANGUAGE SQL STABLE
;
-- Now perspective ----------------------------------------------------------------------------------------------------
-- nCE_Certificate viewed as it currently is (cannot include future versions)
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW certx.nCE_Certificate
AS
SELECT *
  FROM certx.pCE_Certificate(now()::timestamp)
;
-- Latest perspective -------------------------------------------------------------------------------------------------
-- lNT_Notification viewed by the latest available information (may include future versions)
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW certx.lNT_Notification AS
SELECT NT.NT_ID
     , NT.Metadata_NT
     , SNT.NT_SNT_NT_ID
     , SNT.Metadata_NT_SNT
     , SNT.NT_SNT_Notification_SentAt
     , REC.NT_REC_NT_ID
     , REC.Metadata_NT_REC
     , REC.NT_REC_Notification_RemainderCount
  FROM certx.NT_Notification NT
  LEFT 
  JOIN certx.NT_SNT_Notification_SentAt SNT
    ON SNT.NT_SNT_NT_ID = NT.NT_ID
  LEFT 
  JOIN certx.NT_REC_Notification_RemainderCount REC
    ON REC.NT_REC_NT_ID = NT.NT_ID;
;
-- Point-in-time perspective ------------------------------------------------------------------------------------------
-- pNT_Notification viewed as it was on the given timepoint
-----------------------------------------------------------------------------------------------------------------------
 CREATE OR REPLACE FUNCTION certx.pNT_Notification 
      ( changingTimepoint timestamp
      )
RETURNS TABLE 
      ( NT_ID bigint
      , Metadata_NT bigint
      , NT_SNT_NT_ID bigint
      , Metadata_NT_SNT bigint
      , NT_SNT_Notification_SentAt timestamp with time zone
      , NT_REC_NT_ID bigint
      , Metadata_NT_REC bigint
      , NT_REC_Notification_RemainderCount smallint
      ) 
AS 
'
 SELECT NT.NT_ID
      , NT.Metadata_NT
      , SNT.NT_SNT_NT_ID
      , SNT.Metadata_NT_SNT
      , SNT.NT_SNT_Notification_SentAt
      , REC.NT_REC_NT_ID
      , REC.Metadata_NT_REC
      , REC.NT_REC_Notification_RemainderCount
   FROM certx.NT_Notification NT
   LEFT 
   JOIN certx.NT_SNT_Notification_SentAt SNT
     ON SNT.NT_SNT_NT_ID = NT.NT_ID
   LEFT 
   JOIN certx.NT_REC_Notification_RemainderCount REC
     ON REC.NT_REC_NT_ID = NT.NT_ID;
' 
LANGUAGE SQL STABLE
;
-- Now perspective ----------------------------------------------------------------------------------------------------
-- nNT_Notification viewed as it currently is (cannot include future versions)
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW certx.nNT_Notification
AS
SELECT *
  FROM certx.pNT_Notification(now()::timestamp)
;
-- SCHEMA EVOLUTION ---------------------------------------------------------------------------------------------------
--
-- The following tables, views, and functions are used to track schema changes
-- over time, as well as providing every XML that has been 'executed' against
-- the database.
--
-- Schema table -------------------------------------------------------------------------------------------------------
-- The schema table holds every xml that has been executed against the database
-----------------------------------------------------------------------------------------------------------------------
CREATE TABLE IF NOT EXISTS certx._Schema 
     ( version int generated by default as identity primary key
     , activation timestamp not null
     , schema jsonb not null
     )
;
-- Insert the JSON schema (as of now)
INSERT INTO certx._Schema 
     ( activation
     , schema
     )
SELECT current_timestamp
     , '{
   "schema": {
      "format": "0.99.16",
      "date": "2025-12-26",
      "time": "16:41:19",
      "metadata": {
         "changingRange": "timestamp",
         "encapsulation": "certx",
         "identity": "bigint",
         "metadataPrefix": "Metadata",
         "metadataType": "bigint",
         "metadataUsage": "true",
         "changingSuffix": "ChangedAt",
         "identitySuffix": "ID",
         "positIdentity": "bigint",
         "positGenerator": "true",
         "positingRange": "timestamp",
         "positingSuffix": "PositedAt",
         "positorRange": "smallint",
         "positorSuffix": "Positor",
         "reliabilityRange": "decimal(5,2)",
         "reliabilitySuffix": "Reliability",
         "defaultReliability": "1",
         "deleteReliability": "0",
         "assertionSuffix": "Assertion",
         "partitioning": "false",
         "entityIntegrity": "true",
         "restatability": "true",
         "idempotency": "false",
         "assertiveness": "true",
         "naming": "improved",
         "positSuffix": "Posit",
         "annexSuffix": "Annex",
         "chronon": "timestamp",
         "now": "now()",
         "dummySuffix": "Dummy",
         "versionSuffix": "Version",
         "statementTypeSuffix": "StatementType",
         "checksumSuffix": "Checksum",
         "businessViews": "true",
         "decisiveness": "true",
         "equivalence": "false",
         "equivalentSuffix": "EQ",
         "equivalentRange": "smallint",
         "databaseTarget": "PostgreSQL",
         "temporalization": "uni",
         "deletability": "false",
         "deletablePrefix": "Deletable",
         "deletionSuffix": "Deleted",
         "privacy": "Ignore",
         "checksum": "false",
         "triggers": "true",
         "knotAliases": "false"
      },
      "anchor": {
         "US": {
            "id": "US",
            "mnemonic": "US",
            "descriptor": "User",
            "identity": "bigint",
            "metadata": {
               "capsule": "certx",
               "generator": "true"
            },
            "attribute": {
               "UID": {
                  "id": "UID",
                  "mnemonic": "UID",
                  "descriptor": "UserId",
                  "timeRange": "timestamp",
                  "dataRange": "varchar(75)",
                  "metadata": {
                     "privacy": "Ignore",
                     "capsule": "certx",
                     "restatable": "true",
                     "idempotent": "false",
                     "deletable": "false"
                  },
                  "layout": {
                     "x": "351.93",
                     "y": "71.80",
                     "fixed": "false"
                  },
                  "description": {
                     "_description": "Can be email, mobile number or unique id"
                  }
               },
               "NAM": {
                  "id": "NAM",
                  "mnemonic": "NAM",
                  "descriptor": "Name",
                  "timeRange": "timestamp",
                  "dataRange": "varchar(75)",
                  "metadata": {
                     "privacy": "Ignore",
                     "capsule": "certx",
                     "restatable": "true",
                     "idempotent": "false",
                     "deletable": "false"
                  },
                  "layout": {
                     "x": "329.57",
                     "y": "0.78",
                     "fixed": "false"
                  }
               }
            },
            "attributes": [
               "UID",
               "NAM"
            ],
            "layout": {
               "x": "404.98",
               "y": "32.97",
               "fixed": "false"
            }
         },
         "RO": {
            "id": "RO",
            "mnemonic": "RO",
            "descriptor": "Role",
            "identity": "bigint",
            "metadata": {
               "capsule": "certx",
               "generator": "true"
            },
            "attribute": {
               "NAM": {
                  "id": "NAM",
                  "mnemonic": "NAM",
                  "descriptor": "Name",
                  "dataRange": "varchar(75)",
                  "metadata": {
                     "privacy": "Ignore",
                     "capsule": "certx",
                     "idempotent": "false",
                     "deletable": "false"
                  },
                  "layout": {
                     "x": "310.26",
                     "y": "-170.62",
                     "fixed": "false"
                  }
               }
            },
            "attributes": [
               "NAM"
            ],
            "layout": {
               "x": "324.76",
               "y": "-93.79",
               "fixed": "false"
            }
         },
         "AP": {
            "id": "AP",
            "mnemonic": "AP",
            "descriptor": "Application",
            "identity": "bigint",
            "metadata": {
               "capsule": "certx",
               "generator": "true"
            },
            "attribute": {
               "NAM": {
                  "id": "NAM",
                  "mnemonic": "NAM",
                  "descriptor": "Name",
                  "timeRange": "timestamp",
                  "dataRange": "varchar(75)",
                  "metadata": {
                     "privacy": "Ignore",
                     "capsule": "certx",
                     "restatable": "true",
                     "idempotent": "false",
                     "deletable": "false"
                  },
                  "layout": {
                     "x": "582.27",
                     "y": "92.03",
                     "fixed": "false"
                  }
               },
               "UID": {
                  "id": "UID",
                  "mnemonic": "UID",
                  "descriptor": "UniqueId",
                  "dataRange": "varchar(15)",
                  "metadata": {
                     "privacy": "Ignore",
                     "capsule": "certx",
                     "idempotent": "false",
                     "deletable": "false"
                  },
                  "layout": {
                     "x": "642.71",
                     "y": "108.89",
                     "fixed": "false"
                  }
               }
            },
            "attributes": [
               "NAM",
               "UID"
            ],
            "layout": {
               "x": "599.12",
               "y": "179.97",
               "fixed": "false"
            }
         },
         "CL": {
            "id": "CL",
            "mnemonic": "CL",
            "descriptor": "Client",
            "identity": "bigint",
            "metadata": {
               "capsule": "certx",
               "generator": "true"
            },
            "attribute": {
               "NAM": {
                  "id": "NAM",
                  "mnemonic": "NAM",
                  "descriptor": "Name",
                  "dataRange": "varchar(75)",
                  "metadata": {
                     "privacy": "Ignore",
                     "capsule": "certx",
                     "idempotent": "false",
                     "deletable": "false"
                  },
                  "layout": {
                     "x": "391.44",
                     "y": "404.87",
                     "fixed": "false"
                  }
               },
               "EID": {
                  "id": "EID",
                  "mnemonic": "EID",
                  "descriptor": "Email",
                  "timeRange": "timestamp",
                  "dataRange": "varchar(100)",
                  "metadata": {
                     "privacy": "Ignore",
                     "capsule": "certx",
                     "restatable": "true",
                     "idempotent": "false",
                     "deletable": "false"
                  },
                  "layout": {
                     "x": "403.83",
                     "y": "458.85",
                     "fixed": "false"
                  }
               },
               "MNO": {
                  "id": "MNO",
                  "mnemonic": "MNO",
                  "descriptor": "MobileNumber",
                  "timeRange": "timestamp",
                  "dataRange": "varchar(12)",
                  "metadata": {
                     "privacy": "Ignore",
                     "capsule": "certx",
                     "restatable": "true",
                     "idempotent": "false",
                     "deletable": "false"
                  },
                  "layout": {
                     "x": "429.22",
                     "y": "476.97",
                     "fixed": "false"
                  }
               }
            },
            "attributes": [
               "NAM",
               "EID",
               "MNO"
            ],
            "layout": {
               "x": "465.15",
               "y": "408.84",
               "fixed": "false"
            }
         },
         "CE": {
            "id": "CE",
            "mnemonic": "CE",
            "descriptor": "Certificate",
            "identity": "bigint",
            "metadata": {
               "capsule": "certx",
               "generator": "true"
            },
            "attribute": {
               "ION": {
                  "id": "ION",
                  "mnemonic": "ION",
                  "descriptor": "IssuedOn",
                  "dataRange": "timestamp with time zone",
                  "metadata": {
                     "privacy": "Ignore",
                     "capsule": "certx",
                     "idempotent": "false",
                     "deletable": "false"
                  },
                  "layout": {
                     "x": "933.73",
                     "y": "404.40",
                     "fixed": "false"
                  }
               },
               "RON": {
                  "id": "RON",
                  "mnemonic": "RON",
                  "descriptor": "RevokedOn",
                  "dataRange": "timestamp with time zone",
                  "metadata": {
                     "privacy": "Ignore",
                     "capsule": "certx",
                     "idempotent": "false",
                     "deletable": "false"
                  },
                  "layout": {
                     "x": "910.30",
                     "y": "432.82",
                     "fixed": "false"
                  }
               },
               "SNO": {
                  "id": "SNO",
                  "mnemonic": "SNO",
                  "descriptor": "SerialNumber",
                  "dataRange": "varchar(25)",
                  "metadata": {
                     "privacy": "Ignore",
                     "capsule": "certx",
                     "idempotent": "false",
                     "deletable": "false"
                  },
                  "layout": {
                     "x": "885.80",
                     "y": "485.36",
                     "fixed": "false"
                  }
               },
               "LTV": {
                  "id": "LTV",
                  "mnemonic": "LTV",
                  "descriptor": "LastTimeVerifiedOn",
                  "dataRange": "timestamp with time zone",
                  "metadata": {
                     "privacy": "Ignore",
                     "capsule": "certx",
                     "idempotent": "false",
                     "deletable": "false"
                  },
                  "layout": {
                     "x": "919.40",
                     "y": "359.32",
                     "fixed": "false"
                  }
               },
               "CEP": {
                  "id": "CEP",
                  "mnemonic": "CEP",
                  "descriptor": "CertificatePath",
                  "dataRange": "text",
                  "metadata": {
                     "privacy": "Ignore",
                     "capsule": "certx",
                     "idempotent": "false",
                     "deletable": "false"
                  },
                  "layout": {
                     "x": "839.99",
                     "y": "486.85",
                     "fixed": "false"
                  }
               },
               "NAF": {
                  "id": "NAF",
                  "mnemonic": "NAF",
                  "descriptor": "NotAfter",
                  "dataRange": "timestamp with time zone",
                  "metadata": {
                     "privacy": "Ignore",
                     "capsule": "certx",
                     "idempotent": "false",
                     "deletable": "false"
                  },
                  "layout": {
                     "x": "894.99",
                     "y": "313.81",
                     "fixed": "false"
                  }
               }
            },
            "attributes": [
               "ION",
               "RON",
               "SNO",
               "LTV",
               "CEP",
               "NAF"
            ],
            "layout": {
               "x": "839.74",
               "y": "392.40",
               "fixed": "false"
            }
         },
         "NT": {
            "id": "NT",
            "mnemonic": "NT",
            "descriptor": "Notification",
            "identity": "bigint",
            "metadata": {
               "capsule": "certx",
               "generator": "true"
            },
            "attribute": {
               "SNT": {
                  "id": "SNT",
                  "mnemonic": "SNT",
                  "descriptor": "SentAt",
                  "dataRange": "timestamp with time zone",
                  "metadata": {
                     "privacy": "Ignore",
                     "capsule": "certx",
                     "idempotent": "false",
                     "deletable": "false"
                  },
                  "layout": {
                     "x": "666.40",
                     "y": "673.69",
                     "fixed": "false"
                  }
               },
               "REC": {
                  "id": "REC",
                  "mnemonic": "REC",
                  "descriptor": "RemainderCount",
                  "dataRange": "smallint",
                  "metadata": {
                     "privacy": "Ignore",
                     "capsule": "certx",
                     "idempotent": "false",
                     "deletable": "false"
                  },
                  "layout": {
                     "x": "624.05",
                     "y": "635.69",
                     "fixed": "false"
                  }
               }
            },
            "attributes": [
               "SNT",
               "REC"
            ],
            "layout": {
               "x": "665.58",
               "y": "572.56",
               "fixed": "false"
            }
         }
      },
      "anchors": [
         "US",
         "RO",
         "AP",
         "CL",
         "CE",
         "NT"
      ],
      "tie": {
         "US_has_RO_belongsTo": {
            "id": "US_has_RO_belongsTo",
            "anchorRole": {
               "US_has": {
                  "id": "US_has",
                  "role": "has",
                  "type": "US",
                  "identifier": "true"
               },
               "RO_belongsTo": {
                  "id": "RO_belongsTo",
                  "role": "belongsTo",
                  "type": "RO",
                  "identifier": "true"
               }
            },
            "roles": [
               "US_has",
               "RO_belongsTo"
            ],
            "metadata": {
               "capsule": "certx",
               "deletable": "false",
               "idempotent": "false"
            },
            "layout": {
               "x": "341.22",
               "y": "-2.21",
               "fixed": "false"
            }
         },
         "US_accessTo_AP_has": {
            "id": "US_accessTo_AP_has",
            "anchorRole": {
               "US_accessTo": {
                  "id": "US_accessTo",
                  "role": "accessTo",
                  "type": "US",
                  "identifier": "true"
               },
               "AP_has": {
                  "id": "AP_has",
                  "role": "has",
                  "type": "AP",
                  "identifier": "true"
               }
            },
            "roles": [
               "US_accessTo",
               "AP_has"
            ],
            "metadata": {
               "capsule": "certx",
               "deletable": "false",
               "idempotent": "false"
            },
            "layout": {
               "x": "487.85",
               "y": "111.77",
               "fixed": "false"
            }
         },
         "AP_serves_CL_servedBy": {
            "id": "AP_serves_CL_servedBy",
            "anchorRole": {
               "AP_serves": {
                  "id": "AP_serves",
                  "role": "serves",
                  "type": "AP",
                  "identifier": "true"
               },
               "CL_servedBy": {
                  "id": "CL_servedBy",
                  "role": "servedBy",
                  "type": "CL",
                  "identifier": "true"
               }
            },
            "roles": [
               "AP_serves",
               "CL_servedBy"
            ],
            "metadata": {
               "capsule": "certx",
               "deletable": "false",
               "idempotent": "false"
            },
            "layout": {
               "x": "514.99",
               "y": "292.84",
               "fixed": "false"
            }
         },
         "AP_uses_CE_isUsedBy": {
            "id": "AP_uses_CE_isUsedBy",
            "anchorRole": {
               "AP_uses": {
                  "id": "AP_uses",
                  "role": "uses",
                  "type": "AP",
                  "identifier": "true"
               },
               "CE_isUsedBy": {
                  "id": "CE_isUsedBy",
                  "role": "isUsedBy",
                  "type": "CE",
                  "identifier": "true"
               }
            },
            "roles": [
               "AP_uses",
               "CE_isUsedBy"
            ],
            "metadata": {
               "capsule": "certx",
               "deletable": "false",
               "idempotent": "false"
            },
            "layout": {
               "x": "737.01",
               "y": "265.05",
               "fixed": "false"
            }
         },
         "CE_belongsTo_CL_owns": {
            "id": "CE_belongsTo_CL_owns",
            "anchorRole": {
               "CE_belongsTo": {
                  "id": "CE_belongsTo",
                  "role": "belongsTo",
                  "type": "CE",
                  "identifier": "true"
               },
               "CL_owns": {
                  "id": "CL_owns",
                  "role": "owns",
                  "type": "CL",
                  "identifier": "true"
               }
            },
            "roles": [
               "CE_belongsTo",
               "CL_owns"
            ],
            "metadata": {
               "capsule": "certx",
               "deletable": "false",
               "idempotent": "false"
            },
            "layout": {
               "x": "650.75",
               "y": "408.50",
               "fixed": "false"
            }
         },
         "CE_isNotifiedBy_NT_notifies": {
            "id": "CE_isNotifiedBy_NT_notifies",
            "anchorRole": {
               "CE_isNotifiedBy": {
                  "id": "CE_isNotifiedBy",
                  "role": "isNotifiedBy",
                  "type": "CE",
                  "identifier": "true"
               },
               "NT_notifies": {
                  "id": "NT_notifies",
                  "role": "notifies",
                  "type": "NT",
                  "identifier": "true"
               }
            },
            "roles": [
               "CE_isNotifiedBy",
               "NT_notifies"
            ],
            "metadata": {
               "capsule": "certx",
               "deletable": "false",
               "idempotent": "false"
            },
            "layout": {
               "x": "756.73",
               "y": "488.80",
               "fixed": "false"
            }
         },
         "NT_sentTo_CL_receives": {
            "id": "NT_sentTo_CL_receives",
            "anchorRole": {
               "NT_sentTo": {
                  "id": "NT_sentTo",
                  "role": "sentTo",
                  "type": "NT",
                  "identifier": "true"
               },
               "CL_receives": {
                  "id": "CL_receives",
                  "role": "receives",
                  "type": "CL",
                  "identifier": "true"
               }
            },
            "roles": [
               "NT_sentTo",
               "CL_receives"
            ],
            "metadata": {
               "capsule": "certx",
               "deletable": "false",
               "idempotent": "false"
            },
            "layout": {
               "x": "538.17",
               "y": "503.53",
               "fixed": "false"
            }
         }
      },
      "ties": [
         "US_has_RO_belongsTo",
         "US_accessTo_AP_has",
         "AP_serves_CL_servedBy",
         "AP_uses_CE_isUsedBy",
         "CE_belongsTo_CL_owns",
         "CE_isNotifiedBy_NT_notifies",
         "NT_sentTo_CL_receives"
      ]
   }
}'
;
-- Schema expanded view -----------------------------------------------------------------------------------------------
-- A view of the schema table that expands the XML attributes into columns
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW certx._Schema_Expanded 
AS
SELECT version
     , activation
     , (schema -> 'schema' ->> 'format') as format
     , (schema -> 'schema' ->> 'date')::date as date
     , (schema -> 'schema' ->> 'time')::time as time
     , (schema -> 'schema' -> 'metadata' ->> 'temporalization') as temporalization
     , (schema -> 'schema' -> 'metadata' ->> 'databaseTarget') as databaseTarget	
     , (schema -> 'schema' -> 'metadata' ->> 'changingRange') as changingRange
     , (schema -> 'schema' -> 'metadata' ->> 'encapsulation') as encapsulation
     , (schema -> 'schema' -> 'metadata' ->> 'identity') as identity
     , (schema -> 'schema' -> 'metadata' ->> 'metadataPrefix') as metadataPrefix
     , (schema -> 'schema' -> 'metadata' ->> 'metadataType') as metadataType
     , (schema -> 'schema' -> 'metadata' ->> 'metadataUsage') as metadataUsage	
     , (schema -> 'schema' -> 'metadata' ->> 'changingSuffix') as changingSuffix
     , (schema -> 'schema' -> 'metadata' ->> 'identitySuffix') as identitySuffix
     , (schema -> 'schema' -> 'metadata' ->> 'positIdentity') as positIdentity
     , (schema -> 'schema' -> 'metadata' ->> 'positGenerator') as positGenerator	
     , (schema -> 'schema' -> 'metadata' ->> 'positingRange') as positingRange
     , (schema -> 'schema' -> 'metadata' ->> 'positingSuffix') as positingSuffix	
     , (schema -> 'schema' -> 'metadata' ->> 'positorRange') as positorRange
     , (schema -> 'schema' -> 'metadata' ->> 'positorSuffix') as positorSuffix
     , (schema -> 'schema' -> 'metadata' ->> 'reliabilityRange') as reliabilityRange
     , (schema -> 'schema' -> 'metadata' ->> 'reliabilitySuffix') as reliabilitySuffix
     , (schema -> 'schema' -> 'metadata' ->> 'reliableCutoff') as reliableCutoff
     , (schema -> 'schema' -> 'metadata' ->> 'deleteReliability') as deleteReliability	
     , (schema -> 'schema' -> 'metadata' ->> 'reliableSuffix') as reliableSuffix
     , (schema -> 'schema' -> 'metadata' ->> 'partitioning') as partitioning
     , (schema -> 'schema' -> 'metadata' ->> 'entityIntegrity') as entityIntegrity
     , (schema -> 'schema' -> 'metadata' ->> 'restatability') as restatability
     , (schema -> 'schema' -> 'metadata' ->> 'idempotency') as idempotency
     , (schema -> 'schema' -> 'metadata' ->> 'assertiveness') as assertiveness	
     , (schema -> 'schema' -> 'metadata' ->> 'naming') as naming
     , (schema -> 'schema' -> 'metadata' ->> 'positSuffix') as positSuffix	
     , (schema -> 'schema' -> 'metadata' ->> 'annexSuffix') as annexSuffix
     , (schema -> 'schema' -> 'metadata' ->> 'chronon') as chronon
     , (schema -> 'schema' -> 'metadata' ->> 'now') as now
     , (schema -> 'schema' -> 'metadata' ->> 'dummySuffix') as dummySuffix
     , (schema -> 'schema' -> 'metadata' ->> 'statementTypeSuffix') as statementTypeSuffix
     , (schema -> 'schema' -> 'metadata' ->> 'checksumSuffix') as checksumSuffix	
     , (schema -> 'schema' -> 'metadata' ->> 'businessViews') as businessViews
     , (schema -> 'schema' -> 'metadata' ->> 'equivalence') as equivalence
     , (schema -> 'schema' -> 'metadata' ->> 'equivalentSuffix') as equivalentSuffix
     , (schema -> 'schema' -> 'metadata' ->> 'equivalentRange') as equivalentRange	
  FROM certx._Schema
;
-- Anchor view --------------------------------------------------------------------------------------------------------
-- The anchor view shows information about all the anchors in a schema
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW certx._Anchor
AS
SELECT s.version
     , s.activation
     , s.schema -> 'schema' -> 'metadata' ->> 'temporalization' as temporalization	
     , a.key || '_' || v.descriptor as name
     , v.descriptor	
     , a.key as mnemonic	
     , v.metadata ->> 'capsule' as capsule
     , v.identity
     , v.metadata ->> 'generator' as generator
     , coalesce(cardinality(v.attributes),0) as numberOfAttributes
  FROM certx._schema as s
     , jsonb_each(s.schema -> 'schema' -> 'anchor') as a
     , jsonb_to_record(a.value) as v(descriptor text, identity text, "dataRange" text, metadata jsonb, attributes text[])
;	
-- Knot view ----------------------------------------------------------------------------------------------------------
-- The knot view shows information about all the knots in a schema
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW certx._Knot
AS
SELECT s.version
     , s.activation
     , s.schema -> 'schema' -> 'metadata' ->> 'temporalization' as temporalization	
     , k.key || '_' || v.descriptor as name	
     , v.descriptor
     , k.key as mnemonic	
     , v.metadata ->> 'capsule' as capsule
     , v."dataRange" as datarange	
     , v.identity
     , v.metadata ->> 'generator' as generator
     , coalesce(v.metadata ->> 'checksum','false') as checksum
     , v.description	
     , coalesce(v.metadata ->> 'equivalent','false') as equivalent
  FROM certx._schema as s
     , jsonb_each(s.schema -> 'schema' -> 'knot') as k
     , jsonb_to_record(k.value) as v(descriptor text, identity text, "dataRange" text, description text, metadata jsonb)
;
-- Attribute view -----------------------------------------------------------------------------------------------------
-- The attribute view shows information about all the attributes in a schema
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW certx._Attribute
AS
SELECT s.version
     , s.activation
     , s.schema -> 'schema' -> 'metadata' ->> 'temporalization' as temporalization	
     , a.key || '_' || t.key || '_' || (a.value ->> 'descriptor') || '_' || v.descriptor as name
     , v.descriptor 
     , t.key as mnemonic 
     , v.metadata ->> 'capsule' as capsule
     , v."dataRange" as dataRange
     , case when v."knotRange" is null then false else true end as knotted
     , v."knotRange" as knotRange
     , case when v."timeRange" is null then false else true end as historized 
     , v."timeRange" as timeRange 
     , v.metadata ->> 'generator' as generator 
     , v.metadata ->> 'assertive' as assertive 
     , v.metadata ->> 'privacy' as privacy
     , coalesce(v.metadata ->> 'checksum','false') as checksum 
     , coalesce(v.metadata ->> 'equivalent','false') as equivalent
     , v.metadata ->> 'restatable' as restatable 
     , v.metadata ->> 'idempotent' as idempotent 
     , a.key as anchorMnemonic
     , (a.value ->> 'descriptor') as anchorDescriptor
     , (a.value ->> 'identity') as anchorIdentity
     , v.metadata ->> 'deletable' as deletable
     , v.metadata ->> 'encryptionGroup' as encryptionGroup
     , v.description
     , coalesce(cardinality(v.keys),0) as numberKeyOfStops
  FROM certx._schema as s
     , jsonb_each(s.schema -> 'schema' -> 'anchor') as a
     , jsonb_each(a.value -> 'attribute') as t
     , jsonb_to_record(t.value) as v(descriptor text, identity text, "dataRange" text, "knotRange" text, "timeRange" text, description text, metadata jsonb, keys text[]) 
;
-- Tie view -----------------------------------------------------------------------------------------------------------
-- The tie view shows information about all the ties in a schema
-----------------------------------------------------------------------------------------------------------------------
CREATE OR REPLACE VIEW certx._Tie
AS
SELECT s.version
     , s.activation
     , s.schema -> 'schema' -> 'metadata' ->> 'temporalization' as temporalization	
     , t.key as name
     , v.metadata ->> 'capsule' as capsule	
     , case when v."timeRange" is null then false else true end as historized 
     , v."timeRange" as timeRange
     , cardinality(roles) as numberOfRoles
     , array(select value ->> 'role' from jsonb_each(v."anchorRole")) || array(select value ->> 'role' from jsonb_each(v."knotRole")) as roles
     , cardinality(array(select jsonb_object_keys(v."anchorRole"))) as numberOfAnchors
     , array(select split_part(jsonb_object_keys(v."anchorRole"),'_',1)) as anchors
     , coalesce(cardinality(array(select jsonb_object_keys(v."knotRole")))) as numberOfKnots
     , array(select split_part(jsonb_object_keys(v."knotRole"),'_',1)) as knots	
     --, v."anchorRole"
     , cardinality(array(select value ->> 'identifier' from jsonb_each(v."anchorRole") where value ->> 'identifier' = 'true') || array(select value ->> 'identifier' from jsonb_each(v."knotRole") where value ->> 'identifier' = 'true')) as identifiers
     , v.metadata ->> 'generator' as generator 
     , v.metadata ->> 'assertive' as assertive 
     , v.metadata ->> 'restatable' as restatable 
     , v.metadata ->> 'idempotent' as idempotent 
  FROM certx._schema as s
     , jsonb_each(s.schema -> 'schema' -> 'tie') as t
     , jsonb_to_record(t.value) as v("timeRange" text, roles text[], metadata jsonb, "anchorRole" jsonb, "knotRole" jsonb)
;
